<!DOCTYPE html>
<html>

<head>
    <title>Draw a rectangle</title>
</head>

<body >
    <canvas id="canvas" width="640" height="480"></canvas>
</body>



<script>
// Initialisation du contexte WebGL
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl");

if (!gl) {
  console.error("WebGL non supporté.");
}

// Création des shaders (similaires aux rectangles)
const vertexShaderSource = `
  attribute vec2 a_position;
  uniform vec2 u_resolution;
  
  void main() {
    vec2 zeroToOne = a_position / u_resolution;
    vec2 zeroToTwo = zeroToOne * 2.0;
    vec2 clipSpace = zeroToTwo - 1.0;

    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }
`;

const fragmentShaderSource = `
  precision mediump float;
  uniform vec4 u_color;
  
  void main() {
    gl_FragColor = u_color;
  }
`;

// Compilation des shaders
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

// Création du programme
function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }
  return program;
}

const program = createProgram(gl, vertexShader, fragmentShader);

// Localisation des attributs et uniformes
const positionLocation = gl.getAttribLocation(program, "a_position");
const resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution");
const colorUniformLocation = gl.getUniformLocation(program, "u_color");

// Création d'un buffer pour les positions
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

// Tableau pour stocker les particules
const particles = [];

// Fonction pour créer une nouvelle particule
function launchParticle(x, y, angle, speed) {
  const velocityX = Math.cos(angle) * speed;
  const velocityY = Math.sin(angle) * speed;

  particles.push({
    x, y,
    velocityX, velocityY,
    life: 100 // Durée de vie de la particule en frames
  });
}

// Fonction pour dessiner une particule
function drawParticle(particle) {
  const size = 4; // Taille de la particule
  const x1 = particle.x - size / 2;
  const y1 = particle.y - size / 2;
  const x2 = particle.x + size / 2;
  const y2 = particle.y + size / 2;

  // Positions de la particule (petit carré)
  const positions = [
    x1, y1,
    x2, y1,
    x1, y2,
    x1, y2,
    x2, y1,
    x2, y2
  ];

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
  
  // Couleur aléatoire pour chaque particule
  gl.uniform4f(colorUniformLocation, Math.random(), Math.random(), Math.random(), 1);

  gl.drawArrays(gl.TRIANGLES, 0, 6); // 6 vertices pour 2 triangles
}

// Fonction pour animer les particules
function animateParticles() {
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.clearColor(0, 0, 0, 0);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(program);
  gl.enableVertexAttribArray(positionLocation);
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

  particles.forEach((particle, index) => {
    // Mise à jour des positions
    particle.x += particle.velocityX;
    particle.y += particle.velocityY;
    particle.life -= 1;

    // Dessiner la particule
    drawParticle(particle);

    // Retirer la particule si sa vie est écoulée
    if (particle.life <= 0) {
      particles.splice(index, 1);
    }
  });

  requestAnimationFrame(animateParticles);
}

// Lancer des particules depuis une position de départ (exemple)
canvas.addEventListener('click', (event) => {
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;

  // Lancer plusieurs particules avec des angles et des vitesses aléatoires
  for (let i = 0; i < 10; i++) {
    const angle = Math.random() * 2 * Math.PI;
    const speed = Math.random() * 3 + 1; // Vitesse aléatoire
    launchParticle(x, y, angle, speed);
  }
});

// Démarrer l'animation des particules
animateParticles();

</script>

</html>